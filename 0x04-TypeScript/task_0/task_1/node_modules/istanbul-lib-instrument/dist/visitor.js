"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _crypto = require("crypto");

var _template = _interopRequireDefault(require("@babel/template"));

var _sourceCoverage = require("./source-coverage");

var _constants = require("./constants");

var _instrumenter = require("./instrumenter");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

// pattern for istanbul to ignore a section
const COMMENT_RE = /^\s*istanbul\s+ignore\s+(if|else|next)(?=\W|$)/; // pattern for istanbul to ignore the whole file

const COMMENT_FILE_RE = /^\s*istanbul\s+ignore\s+(file)(?=\W|$)/; // source map URL pattern

const SOURCE_MAP_RE = /[#@]\s*sourceMappingURL=(.*)\s*$/m; // generate a variable name from hashing the supplied file path

function genVar(filename) {
  const hash = (0, _crypto.createHash)(_constants.SHA);
  hash.update(filename);
  return 'cov_' + parseInt(hash.digest('hex').substr(0, 12), 16).toString(36);
} // VisitState holds the state of the visitor, provides helper functions
// and is the `this` for the individual coverage visitors.


class VisitState {
  constructor(types, sourceFilePath, inputSourceMap, ignoreClassMethods = []) {
    this.varName = genVar(sourceFilePath);
    this.attrs = {};
    this.nextIgnore = null;
    this.cov = new _sourceCoverage.SourceCoverage(sourceFilePath);

    if (typeof inputSourceMap !== 'undefined') {
      this.cov.inputSourceMap(inputSourceMap);
    }

    this.ignoreClassMethods = ignoreClassMethods;
    this.types = types;
    this.sourceMappingURL = null;
  } // should we ignore the node? Yes, if specifically ignoring
  // or if the node is generated.


  shouldIgnore(path) {
    return this.nextIgnore || !path.node.loc;
  } // extract the ignore comment hint (next|if|else) or null


  hintFor(node) {
    let hint = null;

    if (node.leadingComments) {
      node.leadingComments.forEach(c => {
        const v = (c.value ||
        /* istanbul ignore next: paranoid check */
        '').trim();
        const groups = v.match(COMMENT_RE);

        if (groups) {
          hint = groups[1];
        }
      });
    }

    return hint;
  } // extract a source map URL from comments and keep track of it


  maybeAssignSourceMapURL(node) {
    const extractURL = comments => {
      if (!comments) {
        return;
      }

      comments.forEach(c => {
        const v = (c.value ||
        /* istanbul ignore next: paranoid check */
        '').trim();
        const groups = v.match(SOURCE_MAP_RE);

        if (groups) {
          this.sourceMappingURL = groups[1];
        }
      });
    };

    extractURL(node.leadingComments);
    extractURL(node.trailingComments);
  } // for these expressions the statement counter needs to be hoisted, so
  // function name inference can be preserved


  counterNeedsHoisting(path) {
    return path.isFunctionExpression() || path.isArrowFunctionExpression() || path.isClassExpression();
  } // all the generic stuff that needs to be done on enter for every node


  onEnter(path) {
    const n = path.node;
    this.maybeAssignSourceMapURL(n); // if already ignoring, nothing more to do

    if (this.nextIgnore !== null) {
      return;
    } // check hint to see if ignore should be turned on


    const hint = this.hintFor(n);

    if (hint === 'next') {
      this.nextIgnore = n;
      return;
    } // else check custom node attribute set by a prior visitor


    if (this.getAttr(path.node, 'skip-all') !== null) {
      this.nextIgnore = n;
    } // else check for ignored class methods


    if (path.isFunctionExpression() && this.ignoreClassMethods.some(name => path.node.id && name === path.node.id.name)) {
      this.nextIgnore = n;
      return;
    }

    if (path.isClassMethod() && this.ignoreClassMethods.some(name => name === path.node.key.name)) {
      this.nextIgnore = n;
      return;
    }
  } // all the generic stuff on exit of a node,
  // including reseting ignores and custom node attrs


  onExit(path) {
    // restore ignore status, if needed
    if (path.node === this.nextIgnore) {
      this.nextIgnore = null;
    } // nuke all attributes for the node


    delete path.node.__cov__;
  } // set a node attribute for the supplied node


  setAttr(node, name, value) {
    node.__cov__ = node.__cov__ || {};
    node.__cov__[name] = value;
  } // retrieve a node attribute for the supplied node or null


  getAttr(node, name) {
    const c = node.__cov__;

    if (!c) {
      return null;
    }

    return c[name];
  } //


  increase(type, id, index) {
    const T = this.types;
    const wrap = index !== null ? // If `index` present, turn `x` into `x[index]`.
    x => T.memberExpression(x, T.numericLiteral(index), true) : x => x;
    return T.updateExpression('++', wrap(T.memberExpression(T.memberExpression(T.identifier(this.varName), T.identifier(type)), T.numericLiteral(id), true)));
  }

  insertCounter(path, increment) {
    const T = this.types;

    if (path.isBlockStatement()) {
      path.node.body.unshift(T.expressionStatement(increment));
    } else if (path.isStatement()) {
      path.insertBefore(T.expressionStatement(increment));
    } else if (this.counterNeedsHoisting(path) && T.isVariableDeclarator(path.parentPath)) {
      // make an attempt to hoist the statement counter, so that
      // function names are maintained.
      const parent = path.parentPath.parentPath;

      if (parent && T.isExportNamedDeclaration(parent.parentPath)) {
        parent.parentPath.insertBefore(T.expressionStatement(increment));
      } else if (parent && (T.isProgram(parent.parentPath) || T.isBlockStatement(parent.parentPath))) {
        parent.insertBefore(T.expressionStatement(increment));
      } else {
        path.replaceWith(T.sequenceExpression([increment, path.node]));
      }
    }
    /* istanbul ignore else: not expected */
    else if (path.isExpression()) {
        path.replaceWith(T.sequenceExpression([increment, path.node]));
      } else {
        console.error('Unable to insert counter for node type:', path.node.type);
      }
  }

  insertStatementCounter(path) {
    /* istanbul ignore if: paranoid check */
    if (!(path.node && path.node.loc)) {
      return;
    }

    const index = this.cov.newStatement(path.node.loc);
    const increment = this.increase('s', index, null);
    this.insertCounter(path, increment);
  }

  insertFunctionCounter(path) {
    const T = this.types;
    /* istanbul ignore if: paranoid check */

    if (!(path.node && path.node.loc)) {
      return;
    }

    const n = path.node;
    let dloc = null; // get lo